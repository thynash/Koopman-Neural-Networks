"""
Julia set generators for complex dynamical systems.

This module implements Julia set generators for complex polynomial iterations,
providing trajectory data generation and high-resolution visualization.
"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Dict, Any, Optional, Tuple, Union
import time
from pathlib import Path

from .fractal_generator import FractalGenerator, TrajectoryData


class JuliaSetGenerator(FractalGenerator):
    """
    Generator for Julia set fractals from complex dynamical systems.
    
    Julia sets are generated by iterating complex polynomial functions
    and analyzing the convergence/divergence behavior of trajectories.
    """
    
    def __init__(self, system_params: Dict[str, Any]):
        """
        Initialize Julia set generator with system parameters.
        
        Args:
            system_params: Dictionary containing Julia set parameters
                - c: Complex parameter for z^2 + c iteration
                - max_iter: Maximum iterations for convergence test
                - escape_radius: Radius for divergence detection
                - bounds: Complex plane bounds for trajectory generation
        """
        super().__init__(system_params)
        self.c = complex(system_params.get('c_real', -0.7269), 
                        system_params.get('c_imag', 0.1889))
        self.max_iter = system_params.get('max_iter', 1000)
        self.escape_radius = system_params.get('escape_radius', 2.0)
        self.bounds = system_params.get('bounds', (-2, 2, -2, 2))  # (xmin, xmax, ymin, ymax)
        
    def _julia_iteration(self, z: complex) -> Tuple[complex, int, bool]:
        """
        Perform Julia set iteration z_{n+1} = z_n^2 + c.
        
        Args:
            z: Initial complex point
            
        Returns:
            Tuple of (final_z, iterations, converged)
        """
        original_z = z
        for i in range(self.max_iter):
            if abs(z) > self.escape_radius:
                return z, i, False  # Diverged
            z = z**2 + self.c
        
        return z, self.max_iter, True  # Converged (or bounded)
    
    def _generate_trajectory_from_point(self, start_z: complex, n_points: int) -> np.ndarray:
        """
        Generate a trajectory starting from a specific point.
        
        Args:
            start_z: Starting complex point
            n_points: Number of trajectory points to generate
            
        Returns:
            Array of trajectory points as [real, imag] pairs
        """
        trajectory = np.zeros((n_points, 2))
        z = start_z
        
        for i in range(n_points):
            trajectory[i] = [z.real, z.imag]
            
            # Check for divergence
            if abs(z) > self.escape_radius:
                # If diverged, fill remaining points with NaN or stop
                trajectory[i:] = np.nan
                break
                
            # Apply Julia iteration
            z = z**2 + self.c
        
        return trajectory
    
    def _sample_initial_points(self, n_trajectories: int) -> np.ndarray:
        """
        Sample initial points from the complex plane.
        
        Args:
            n_trajectories: Number of initial points to sample
            
        Returns:
            Array of complex initial points
        """
        xmin, xmax, ymin, ymax = self.bounds
        
        # Sample points uniformly in the complex plane
        real_parts = self.rng.uniform(xmin, xmax, n_trajectories)
        imag_parts = self.rng.uniform(ymin, ymax, n_trajectories)
        
        return real_parts + 1j * imag_parts
    
    def generate_trajectories(self, n_points: int, **kwargs) -> TrajectoryData:
        """
        Generate Julia set trajectory data.
        
        Args:
            n_points: Total number of trajectory points to generate
            **kwargs: Additional parameters
                - trajectory_length: Length of each individual trajectory
                - n_trajectories: Number of separate trajectories
                - filter_divergent: Whether to filter out divergent trajectories
                
        Returns:
            TrajectoryData containing Julia set trajectories
        """
        trajectory_length = kwargs.get('trajectory_length', 100)
        n_trajectories = max(1, n_points // trajectory_length)
        filter_divergent = kwargs.get('filter_divergent', True)
        
        # Sample initial points
        initial_points = self._sample_initial_points(n_trajectories)
        
        all_states = []
        all_next_states = []
        
        for start_z in initial_points:
            # Generate trajectory from this starting point
            trajectory = self._generate_trajectory_from_point(start_z, trajectory_length + 1)
            
            # Check if trajectory is valid (not all NaN)
            if filter_divergent and np.any(np.isnan(trajectory)):
                # Skip divergent trajectories if filtering is enabled
                continue
            
            # Remove NaN values if any
            valid_mask = ~np.isnan(trajectory).any(axis=1)
            valid_trajectory = trajectory[valid_mask]
            
            if len(valid_trajectory) > 1:
                states = valid_trajectory[:-1]
                next_states = valid_trajectory[1:]
                
                all_states.append(states)
                all_next_states.append(next_states)
        
        # Concatenate all trajectories
        if not all_states:
            raise ValueError("No valid trajectories generated. Try different parameters.")
        
        states = np.vstack(all_states)
        next_states = np.vstack(all_next_states)
        
        # Trim to requested number of points
        if len(states) > n_points:
            indices = self.rng.choice(len(states), n_points, replace=False)
            states = states[indices]
            next_states = next_states[indices]
        
        # Create metadata
        metadata = {
            'system_type': 'Julia Set',
            'system_name': self.get_system_name(),
            'c_parameter': {'real': self.c.real, 'imag': self.c.imag},
            'max_iter': self.max_iter,
            'escape_radius': self.escape_radius,
            'bounds': self.bounds,
            'n_points': len(states),
            'n_trajectories': len(all_states),
            'trajectory_length': trajectory_length,
            'filter_divergent': filter_divergent,
            'generation_time': time.time(),
            'seed': self.system_params.get('seed', 42)
        }
        
        return TrajectoryData(
            states=states,
            next_states=next_states,
            system_params=self.system_params,
            metadata=metadata
        )
    
    def generate_attractor_grid(self, resolution: int = 1000) -> Tuple[np.ndarray, np.ndarray]:
        """
        Generate a grid visualization of the Julia set attractor.
        
        Args:
            resolution: Grid resolution for visualization
            
        Returns:
            Tuple of (grid_points, iteration_counts)
        """
        xmin, xmax, ymin, ymax = self.bounds
        
        # Create coordinate grids
        x = np.linspace(xmin, xmax, resolution)
        y = np.linspace(ymin, ymax, resolution)
        X, Y = np.meshgrid(x, y)
        
        # Convert to complex grid
        Z = X + 1j * Y
        
        # Compute iteration counts for each point
        iteration_counts = np.zeros_like(Z, dtype=int)
        
        for i in range(resolution):
            for j in range(resolution):
                z = Z[i, j]
                _, iters, _ = self._julia_iteration(z)
                iteration_counts[i, j] = iters
        
        return Z, iteration_counts
    
    def visualize_attractor(self, data: TrajectoryData, save_path: str,
                           dpi: int = 600, figsize: Tuple[float, float] = (10, 10),
                           use_grid: bool = True, grid_resolution: int = 1000) -> None:
        """
        Create high-resolution visualization of the Julia set.
        
        Args:
            data: TrajectoryData containing trajectory points
            save_path: Path to save the visualization
            dpi: Resolution in dots per inch (minimum 600)
            figsize: Figure size in inches
            use_grid: Whether to use grid-based visualization
            grid_resolution: Resolution for grid visualization
        """
        if dpi < 600:
            raise ValueError("DPI must be at least 600 for publication quality")
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=figsize, dpi=dpi)
        
        # Left plot: Trajectory points
        ax1.scatter(data.states[:, 0], data.states[:, 1], 
                   s=0.1, c='blue', alpha=0.6, marker='.')
        ax1.set_title(f'Julia Set Trajectories\nc = {self.c:.4f}', fontsize=12)
        ax1.set_xlabel('Real')
        ax1.set_ylabel('Imaginary')
        ax1.set_aspect('equal')
        ax1.grid(True, alpha=0.3)
        
        # Right plot: Grid-based attractor visualization
        if use_grid:
            Z, iteration_counts = self.generate_attractor_grid(grid_resolution)
            
            # Create colormap based on iteration counts
            im = ax2.imshow(iteration_counts, extent=self.bounds, 
                           cmap='hot', origin='lower', interpolation='bilinear')
            ax2.set_title(f'Julia Set Attractor\nMax Iter: {self.max_iter}', fontsize=12)
            ax2.set_xlabel('Real')
            ax2.set_ylabel('Imaginary')
            
            # Add colorbar
            plt.colorbar(im, ax=ax2, label='Iterations to Divergence')
        else:
            # Just plot trajectory points on both axes
            ax2.scatter(data.states[:, 0], data.states[:, 1], 
                       s=0.1, c='red', alpha=0.6, marker='.')
            ax2.set_title('Julia Set Points', fontsize=12)
            ax2.set_xlabel('Real')
            ax2.set_ylabel('Imaginary')
            ax2.set_aspect('equal')
            ax2.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig(save_path, dpi=dpi, bbox_inches='tight',
                   facecolor='white', edgecolor='none')
        plt.close()
    
    def get_system_name(self) -> str:
        """Return system identifier."""
        return f"Julia Set (c={self.c:.4f})"
    
    def validate_parameters(self) -> bool:
        """
        Validate Julia set parameters.
        
        Returns:
            True if parameters are valid, False otherwise
        """
        # Check that escape radius is positive
        if self.escape_radius <= 0:
            return False
        
        # Check that max_iter is positive
        if self.max_iter <= 0:
            return False
        
        # Check that bounds are valid
        xmin, xmax, ymin, ymax = self.bounds
        if xmin >= xmax or ymin >= ymax:
            return False
        
        return True


class MandelbrotSetGenerator(JuliaSetGenerator):
    """
    Generator for Mandelbrot set (special case where c varies and z0 = 0).
    
    The Mandelbrot set uses the same iteration formula z_{n+1} = z_n^2 + c
    but varies c while keeping the initial point z0 = 0.
    """
    
    def __init__(self, system_params: Dict[str, Any]):
        """Initialize Mandelbrot set generator."""
        super().__init__(system_params)
        # For Mandelbrot set, we'll sample different c values
        
    def generate_trajectories(self, n_points: int, **kwargs) -> TrajectoryData:
        """
        Generate Mandelbrot set trajectory data.
        
        For Mandelbrot set, we sample different c values and use z0 = 0.
        """
        trajectory_length = kwargs.get('trajectory_length', 100)
        n_trajectories = max(1, n_points // trajectory_length)
        
        # Sample c values from the complex plane
        c_values = self._sample_initial_points(n_trajectories)
        
        all_states = []
        all_next_states = []
        
        for c in c_values:
            # For Mandelbrot set, always start at z0 = 0
            self.c = c  # Update c parameter
            trajectory = self._generate_trajectory_from_point(0+0j, trajectory_length + 1)
            
            # Remove NaN values if any
            valid_mask = ~np.isnan(trajectory).any(axis=1)
            valid_trajectory = trajectory[valid_mask]
            
            if len(valid_trajectory) > 1:
                states = valid_trajectory[:-1]
                next_states = valid_trajectory[1:]
                
                all_states.append(states)
                all_next_states.append(next_states)
        
        if not all_states:
            raise ValueError("No valid trajectories generated. Try different parameters.")
        
        states = np.vstack(all_states)
        next_states = np.vstack(all_next_states)
        
        # Trim to requested number of points
        if len(states) > n_points:
            indices = self.rng.choice(len(states), n_points, replace=False)
            states = states[indices]
            next_states = next_states[indices]
        
        metadata = {
            'system_type': 'Mandelbrot Set',
            'system_name': 'Mandelbrot Set',
            'max_iter': self.max_iter,
            'escape_radius': self.escape_radius,
            'bounds': self.bounds,
            'n_points': len(states),
            'n_trajectories': len(all_states),
            'trajectory_length': trajectory_length,
            'generation_time': time.time(),
            'seed': self.system_params.get('seed', 42)
        }
        
        return TrajectoryData(
            states=states,
            next_states=next_states,
            system_params=self.system_params,
            metadata=metadata
        )
    
    def get_system_name(self) -> str:
        """Return system identifier."""
        return "Mandelbrot Set"


def create_julia_generator(system_type: str, **kwargs) -> JuliaSetGenerator:
    """
    Factory function to create Julia set generators.
    
    Args:
        system_type: Type of system ('julia' or 'mandelbrot')
        **kwargs: System parameters
        
    Returns:
        Appropriate Julia set generator instance
    """
    if system_type.lower() in ['julia', 'julia_set']:
        return JuliaSetGenerator(kwargs)
    elif system_type.lower() in ['mandelbrot', 'mandelbrot_set']:
        return MandelbrotSetGenerator(kwargs)
    else:
        raise ValueError(f"Unknown Julia set system type: {system_type}")