"""
Iterated Function System (IFS) generators for fractal attractors.

This module implements IFS generators for Sierpinski gasket and Barnsley fern
fractals, providing trajectory data generation and high-resolution visualization.
"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Dict, Any, Optional, Tuple
import time
from pathlib import Path

from .fractal_generator import FractalGenerator, TrajectoryData


class IFSGenerator(FractalGenerator):
    """
    Base class for Iterated Function System generators.
    
    IFS fractals are generated by repeatedly applying one of several
    contractive transformations to create self-similar structures.
    """
    
    def __init__(self, system_params: Dict[str, Any]):
        """
        Initialize IFS generator with system parameters.
        
        Args:
            system_params: Dictionary containing IFS-specific parameters
        """
        super().__init__(system_params)
        self.transformations = self._define_transformations()
        self.probabilities = self._define_probabilities()
        
    def _define_transformations(self) -> list:
        """Define the affine transformations for the IFS."""
        raise NotImplementedError("Subclasses must implement transformation definitions")
    
    def _define_probabilities(self) -> np.ndarray:
        """Define the selection probabilities for each transformation."""
        raise NotImplementedError("Subclasses must implement probability definitions")
    
    def _apply_transformation(self, point: np.ndarray, transform_idx: int) -> np.ndarray:
        """
        Apply a specific transformation to a point.
        
        Args:
            point: 2D point [x, y]
            transform_idx: Index of transformation to apply
            
        Returns:
            Transformed point
        """
        transform = self.transformations[transform_idx]
        
        # Affine transformation: [x', y'] = A * [x, y] + b
        A = transform['matrix']
        b = transform['translation']
        
        return A @ point + b
    
    def generate_trajectories(self, n_points: int, **kwargs) -> TrajectoryData:
        """
        Generate IFS trajectory data.
        
        Args:
            n_points: Number of trajectory points to generate
            **kwargs: Additional parameters (start_point, skip_initial)
            
        Returns:
            TrajectoryData containing IFS trajectory
        """
        start_point = kwargs.get('start_point', np.array([0.0, 0.0]))
        skip_initial = kwargs.get('skip_initial', 1000)  # Skip transient behavior
        
        # Generate trajectory with extra points for skipping transients
        total_points = n_points + skip_initial
        trajectory = np.zeros((total_points, 2))
        trajectory[0] = start_point
        
        # Generate trajectory by iteratively applying transformations
        for i in range(1, total_points):
            # Select transformation based on probabilities
            transform_idx = self.rng.choice(len(self.transformations), p=self.probabilities)
            
            # Apply selected transformation
            trajectory[i] = self._apply_transformation(trajectory[i-1], transform_idx)
        
        # Skip initial transient points
        states = trajectory[skip_initial:-1]
        next_states = trajectory[skip_initial+1:]
        
        # Create metadata
        metadata = {
            'system_type': 'IFS',
            'system_name': self.get_system_name(),
            'n_points': n_points,
            'skip_initial': skip_initial,
            'generation_time': time.time(),
            'seed': self.system_params.get('seed', 42),
            'transformations': len(self.transformations),
            'start_point': start_point.tolist()
        }
        
        return TrajectoryData(
            states=states,
            next_states=next_states,
            system_params=self.system_params,
            metadata=metadata
        )
    
    def visualize_attractor(self, data: TrajectoryData, save_path: str, 
                           dpi: int = 600, figsize: Tuple[float, float] = (8, 8)) -> None:
        """
        Create high-resolution visualization of the fractal attractor.
        
        Args:
            data: TrajectoryData containing the fractal points
            save_path: Path to save the visualization
            dpi: Resolution in dots per inch (minimum 600)
            figsize: Figure size in inches
        """
        if dpi < 600:
            raise ValueError("DPI must be at least 600 for publication quality")
        
        fig, ax = plt.subplots(figsize=figsize, dpi=dpi)
        
        # Plot the attractor points
        ax.scatter(data.states[:, 0], data.states[:, 1], 
                  s=0.1, c='black', alpha=0.7, marker='.')
        
        # Set equal aspect ratio and remove axes for clean visualization
        ax.set_aspect('equal')
        ax.axis('off')
        
        # Set title
        system_name = data.metadata.get('system_name', 'IFS Attractor')
        ax.set_title(f'{system_name} Attractor ({len(data.states)} points)', 
                    fontsize=14, pad=20)
        
        # Tight layout and save
        plt.tight_layout()
        plt.savefig(save_path, dpi=dpi, bbox_inches='tight', 
                   facecolor='white', edgecolor='none')
        plt.close()


class SierpinskiGasketGenerator(IFSGenerator):
    """
    Generator for Sierpinski gasket fractal using IFS.
    
    The Sierpinski gasket is generated using three contractive transformations
    that map points toward the vertices of an equilateral triangle.
    """
    
    def _define_transformations(self) -> list:
        """
        Define the three transformations for Sierpinski gasket.
        
        Each transformation scales by 0.5 and translates toward a triangle vertex.
        """
        scale = 0.5
        
        transformations = [
            {
                'matrix': np.array([[scale, 0], [0, scale]]),
                'translation': np.array([0, 0])
            },
            {
                'matrix': np.array([[scale, 0], [0, scale]]),
                'translation': np.array([scale, 0])
            },
            {
                'matrix': np.array([[scale, 0], [0, scale]]),
                'translation': np.array([scale/2, scale * np.sqrt(3)/2])
            }
        ]
        
        return transformations
    
    def _define_probabilities(self) -> np.ndarray:
        """Equal probability for each transformation."""
        return np.array([1/3, 1/3, 1/3])
    
    def get_system_name(self) -> str:
        """Return system identifier."""
        return "Sierpinski Gasket"
    
    def validate_parameters(self) -> bool:
        """Validate Sierpinski gasket parameters."""
        # Sierpinski gasket has fixed mathematical structure
        return True


class BarnsleyFernGenerator(IFSGenerator):
    """
    Generator for Barnsley fern fractal using IFS.
    
    The Barnsley fern uses four affine transformations with different
    probabilities to create a fern-like structure.
    """
    
    def _define_transformations(self) -> list:
        """
        Define the four transformations for Barnsley fern.
        
        Based on the classic Barnsley fern parameters.
        """
        transformations = [
            # Stem (f1)
            {
                'matrix': np.array([[0, 0], [0, 0.16]]),
                'translation': np.array([0, 0])
            },
            # Successively smaller leaflets (f2)
            {
                'matrix': np.array([[0.85, 0.04], [-0.04, 0.85]]),
                'translation': np.array([0, 1.6])
            },
            # Largest left-hand leaflet (f3)
            {
                'matrix': np.array([[0.2, -0.26], [0.23, 0.22]]),
                'translation': np.array([0, 1.6])
            },
            # Largest right-hand leaflet (f4)
            {
                'matrix': np.array([[-0.15, 0.28], [0.26, 0.24]]),
                'translation': np.array([0, 0.44])
            }
        ]
        
        return transformations
    
    def _define_probabilities(self) -> np.ndarray:
        """Define probabilities for Barnsley fern transformations."""
        return np.array([0.01, 0.85, 0.07, 0.07])
    
    def get_system_name(self) -> str:
        """Return system identifier."""
        return "Barnsley Fern"
    
    def validate_parameters(self) -> bool:
        """Validate Barnsley fern parameters."""
        # Check that probabilities sum to 1
        prob_sum = np.sum(self.probabilities)
        return abs(prob_sum - 1.0) < 1e-10


def create_ifs_generator(system_type: str, **kwargs) -> IFSGenerator:
    """
    Factory function to create IFS generators.
    
    Args:
        system_type: Type of IFS system ('sierpinski' or 'barnsley_fern')
        **kwargs: Additional system parameters
        
    Returns:
        Appropriate IFS generator instance
    """
    system_params = kwargs
    
    if system_type.lower() in ['sierpinski', 'sierpinski_gasket']:
        return SierpinskiGasketGenerator(system_params)
    elif system_type.lower() in ['barnsley', 'barnsley_fern', 'fern']:
        return BarnsleyFernGenerator(system_params)
    else:
        raise ValueError(f"Unknown IFS system type: {system_type}")